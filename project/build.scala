import sbt._
import Keys._
import sbtassembly.AssemblyPlugin.autoImport._

object build extends Build {

  lazy val sharedSettings = Defaults.coreDefaultSettings ++ Seq(
    organization := "jp.ac.u_tokyo.i.ci.csg.hiroshi_yamaguchi",
    version := "3.0.0-SNAPSHOT",
    description := "Inverse macros, macro paradise, etc.",
    resolvers ++= Seq(
      Resolver.sonatypeRepo("snapshots"),
      Resolver.sonatypeRepo("releases")),
    publishTo := Some(Resolver.file("file", file("target") / "repo")),
    publishMavenStyle := true,
    publishArtifact := false,
    parallelExecution in Test := false,
    logBuffered := false,
    scalaOrganization := "org.scala-lang",
    scalaVersion := "2.11.7",
    crossScalaVersions := Seq("2.11.7", "2.12.0-M3"),
    crossVersion := CrossVersion.full,
    scalacOptions ++= Seq("-feature", "-deprecation", "-unchecked", "-explaintypes"),
    scalacOptions ++= Seq("-Xlint", "-Yinline-warnings"),
    scalacOptions <+= scalaVersion map { ver =>
      if (ver startsWith "2.12.0")
        "-Yopt:l:classpath"
      else
        "-optimise"
    },
    javacOptions ++= Seq("-source", "1.8", "-target", "1.8"),
    libraryDependencies <++= (scalaOrganization, scalaVersion) { (org, ver) => Seq(
      org % "scala-compiler" % ver,
      org % "scala-library" % ver,
      org % "scala-reflect" % ver, {
        if (ver == "2.12.0-M3")
          "org.scalatest" %% "scalatest" % "2.2.5-M3" % Test
        else
          "org.scalatest" %% "scalatest" % "2.2.6" % Test
      },
      "org.scalacheck" %% "scalacheck" % "1.12.5" % Test
    )
    },
    libraryDependencies += "junit" % "junit" % "4.12" % Test
  )

  implicit class ProjectOps(val project: Project) extends AnyVal {

    //==== type of projects ====

    def common(location: String, name: String): Project =
      project.in(file(location) / name).settings(sharedSettings: _*)

    def aggregated(location: String)(projects: ProjectReference*): Project =
      project.in(file(location)).settings(sharedSettings: _*).aggregate(projects: _*)

    def compilerPlugin(name: String): Project =
      common("core", name).hasArtifact.settings(
        resourceDirectory in Compile <<= baseDirectory(_ / "src" / "main" / "scala" / "inverse_macros" / "embedded"),
        // exclude macro paradise from dependency to avoid enterSym conflicts
        ivyConfigurations += CompileOnly,
        unmanagedJars in Compile ++= update.value.select(configurationFilter(CompileOnly.name)),
        // avoid a scalac-plugin.xml conflict
        assemblyOption in assembly := (assemblyOption in assembly).value.copy(includeScala = false),
        assemblyMergeStrategy in assembly := {
          case PathList("scalac-plugin.xml") => MergeStrategy.first
          case x =>
            val oldStrategy = (assemblyMergeStrategy in assembly).value
            oldStrategy(x)
        },
        // publish an artifact generated by assembly since a compiler plugin must be an all-in-one jar file.
        publishArtifact in(Compile, packageBin) := false,
        addArtifact(artifact in(Compile, assembly), assembly)
      )

    def imEngine(name: String): Project = common("core", name).hasArtifact.usesParadise

    def imEngineTest(name: String)(implicit plugin: Project @@ CorePlugin, engine: Project @@ CoreEngine): Project =
      common("test", name).usesInverseMacros

    def paradiseTest(name: String)(implicit plugin: Project @@ CorePlugin, engine: Project @@ CoreEngine): Project =
      imEngineTest(name).settings(
        unmanagedSourceDirectories in Test <<= (scalaSource in Test) { (root: File) =>
          val (anns :: Nil, others) = root.listFiles.toList.partition(_.getName == "annotations")
          System.setProperty("sbt.paths.tests.scaladoc",
            anns.listFiles.toList.filter(_.getName == "scaladoc").head.getAbsolutePath)
          anns.listFiles.toList ++ others
        },
        fullClasspath in Test := {
          val testcp =
            (fullClasspath in Test).value.files.map(_.getAbsolutePath).mkString(java.io.File.pathSeparatorChar.toString)
          sys.props("sbt.paths.tests.classpath") = testcp
          (fullClasspath in Test).value
        }
      )

    def dsl(name: String)(implicit plugin: Project @@ CorePlugin, engine: Project @@ CoreEngine): Project =
      common("dsl", name).usesInverseMacros.hasArtifact

    def experiment(experimentName: String, packageName: String)(implicit common: Project @@ ExperimentsCommon): Project =
      project.in(file("experiments") / packageName / experimentName).dependsOn(common : Project).
        settings(sharedSettings: _*).
        settings(
          crossScalaVersions := Seq("2.11.7"),
          assemblyOutputPath in assembly <<= (assemblyJarName in assembly) map (file("target") / "experiments" / _),
          assemblyJarName in assembly := s"${experimentName}_$packageName.jar",
          mainClass in assembly := Some(s"$packageName.MicroBench")
        )

    def contExperiment(experimentName: String)(implicit engine: Project @@ CoreEngine, common: Project @@ ExperimentsCommon): Project =
      project.experiment(experimentName, "scala.util.continuations").
        usesContinuation.makeSureOfDependency(engine)

    def imExperiment(experimentName: String, packageName: String)
                    (implicit plugin: Project @@ CorePlugin, engine: Project @@ CoreEngine, common: Project @@ ExperimentsCommon): Project =
      project.experiment(experimentName, s"inverse_macros.$packageName").usesInverseMacros

    //==== auxiliary methods ====

    def dependsOnParadise: Project = project.settings(
      libraryDependencies += "org.scalamacros" % "paradise" % "2.1.0" % CompileOnly cross CrossVersion.full)

    def usesParadise: Project = project.settings(
      addCompilerPlugin("org.scalamacros" % "paradise" % "2.1.0" cross CrossVersion.full))

    // use assembly instead of Keys.`package` since a compiler plugin must be an all-in-one jar file.
    def usesLocalPlugins(plugins: Project*): Project = project.settings(
      plugins.map { plugin =>
        scalacOptions in Compile <++= (assembly in(plugin, Compile)) map { (jar: File) =>
          System.setProperty("sbt.paths.plugin.jar", jar.getAbsolutePath)
          val addPlugin = "-Xplugin:" + jar.getAbsolutePath
          // Thanks Jason for this cool idea (taken from https://github.com/retronym/boxer)
          // add plugin timestamp to compiler options to trigger recompile of
          // main after editing the plugin. (Otherwise a 'clean' is needed.)
          val dummy = "-Jdummy=" + jar.lastModified
          Seq(addPlugin, dummy)
        }
      }: _*
    )

    def makeSureOfDependency(dependency: Project): Project = project.dependsOn(dependency).settings(
      scalacOptions in Compile <+= (Keys.`package` in(dependency, Compile)) map { (jar: File) =>
        "-Jdummy=" + jar.lastModified
      }
    )

    def usesInverseMacros(implicit plugin: Project @@ CorePlugin, engine: Project @@ CoreEngine): Project =
      project.usesLocalPlugins(plugin).makeSureOfDependency(engine)

    def usesContinuation: Project = project.settings(
      addCompilerPlugin("org.scala-lang.plugins" % "scala-continuations-plugin" % "1.0.2" cross CrossVersion.full),
      scalacOptions += "-P:continuations:enable",
      libraryDependencies += "org.scala-lang.plugins" %% "scala-continuations-library" % "1.0.2"
    )

    def shareWith(share: Project): Project = project.settings(
      sourceDirectory <<= sourceDirectory in share
    )

    def addOption(option: String): Project = project.settings(
      scalacOptions += s"-P:invmacs:$option"
    )

    def hasArtifact: Project = project.settings(
      publishArtifact := true,
      publishArtifact in Test := false
    )

    def setDefaultCorePlugin(): Project = {
      Implicits.defaultCorePlugin = project.tag[CorePlugin]
      project
    }

    def setDefaultCoreEngine(): Project = {
      Implicits.defaultCoreEngine = project.tag[CoreEngine]
      project
    }

    def setExperimentsCommon(): Project = {
      Implicits.defaultExperimentsCommon = project.tag[ExperimentsCommon]
      project
    }

    def tag[Tag]: Project @@ Tag = project.asInstanceOf[Project @@ Tag]
  }

  lazy val CompileOnly = config("compileonly").hide.describedAs("Compile-time only")

  type @@[A, T] = {
    type Tag = T
    type Self = A
  }

  implicit def unwrapTag[A, T](tagged: A @@ T): A = tagged.asInstanceOf[A]

  class CorePlugin

  class CoreEngine

  class ExperimentsCommon

  object Implicits {
    implicit var defaultCorePlugin: Project @@ CorePlugin = _
    implicit var defaultCoreEngine: Project @@ CoreEngine = _
    implicit var defaultExperimentsCommon: Project @@ ExperimentsCommon = _
  }

  concurrentRestrictions in Global := Seq(Tags.exclusive(Tags.Test))
}
